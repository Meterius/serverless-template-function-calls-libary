const { kebabCase } = require("change-case");
const fs = require("fs");

/**
 * converts string to kebab case
 * @param {String} str
 * @returns {String}
 */
function toKebabCase(str){
    return kebabCase(str);
}

/**
 * checks whether val is an object
 * @param {*} val
 * @returns {boolean}
 */
function isObject(val){
    return typeof val === "object" && val;
}

/**
 * create shallow copy
 * @param {*} val
 * @returns {*}
 */
function shallowCopy(val){
    if(Array.isArray(val)){
        return val.slice(0);
    } else if(isObject(val)){
        const copyObject = {};

        Object.keys(val).forEach((key) => {
            copyObject[key] = val[key];
        });

        return copyObject;
    } else {
        return val;
    }
}

/**
 * create deep copy
 * @param {*} val
 * @returns {*}
 */
function copy(val){
    if(Array.isArray(val)){
        return val.map(copy);
    } else if(isObject(val)){
        const copyObject = {};

        Object.keys(val).forEach((key) => {
            copyObject[key] = copy(val[key]);
        });

        return copyObject;
    } else {
        return val;
    }
}

/**
 * sets properties on element, calls the function on the element and resets properties on element to the previous values
 * @param {*} element
 * @param {Function} func
 * @param {Object} props
 */
function setCallDel(element, func, props){
    const prev = {};

    Object.keys(props).forEach((key) => {
        prev[key] = element[key];
        element[key] = props[key];
    });

    func(element);

    Object.keys(props).forEach((key) => {
        element[key] = prev[key];
    });
}

/**
 * merges elements of multiple arrays into single array
 * @param {Array[]} superArray
 * @returns {Array}
 */
function mergeArrays(superArray){
    const mergedArr = [];

    superArray.forEach((arr) => {
        mergedArr.concat(arr);
    });

    return mergedArr;
}

/**
 * merges properties ignoring ones with double underscores of objects in array into single object
 * @throws {Error} properties are not be specified multiple times
 * @param {Object[]} arr
 * @returns {Object}
 */
function mergeProps(arr) {
    const merged = {};
    const props = [];

    arr.forEach((container) => {
        Object.keys(container).forEach((prop) => {
            if(props.includes(prop)){
                throw new Error("merging properties encountered multiple definitions of \"" + prop + "\"");
            }

            if(prop.substr(0, 2) !== "__"){
                merged[prop] = container[prop];
                props.push(prop);
            }
        });
    });

    return merged;
}

/**
 * substitutes string variable in the keys and values of the content recursively with a value
 * @param {Object} options
 * @param {String} options.variable
 * @param {String} options.value
 * @param {*} options.content
 * @returns {*}
 */
function substitute(options) {
    const { variable, value, content } = options;

    function recSub(element){
        if(isObject(element)) {
            const subElement = {};

            Object.keys(element).forEach((key) => {
                subElement[key.replace(variable, value)] = recSub(element[key]);
            });

            return subElement;
        } else if(typeof element === "string"){
            return element.replace(variable, value);
        } else {
            return element;
        }
    }

    return recSub(content);
}

/**
 * substitutes string variable in the keys and values of the content recursively with multiple values and returns
 * each possible substitution in an array
 * @param {Object} options
 * @param {String} options.variable
 * @param {String[]} options.values
 * @param {*} options.content
 * @returns {*}
 */
function mapSubstitute(options) {
    const { variable, values, content } = options;

    return values.map(value => substitute({ variable, value, content: copy(content) }));
}

/**
 * inserts auto generated aws resource names if none are already set,
 * these are generated by concatenating the prefix and the logic resource name converted to by
 * the converter which defaults to a kebab case converter. also note that names are also generated
 * for inline policy for aws roles and that for bucket names underscores are replaced by dots
 * @param {*} options.content
 * @param {String} options.prefix
 * @param {Function} [options.converter=toKebabCase]
 * @returns {*}
 */
function insertAwsResourceNames(options) {
    const { content, prefix, converter = toKebabCase } = options;

    const resTypeRegex = /^(?<type>AWS::.*::(?<localType>.*)(?!::))$/;

    const normalNameTypes = ["AWS::CodeBuild::Project", "AWS::CodePipeline::Pipeline"];

    const specialNameConverterTypes = {
        "AWS::S3::Bucket": (name) => name.replace("_", ".")
    };

    if(isObject(content)){
        Object.keys(content).forEach((key) => {
            const element = content[key];

            if(isObject(element)) {
                insertAwsResourceNames({ ...options, content: element });

                const typeData = resTypeRegex.exec(element.Type);
                if (typeData) {
                    const nameConverter = specialNameConverterTypes[element.Type] || (name => name);
                    const nameProp = normalNameTypes.includes(typeData.groups.type) ? "Name" : typeData.groups.localType + "Name";
                    const name = prefix + converter(key);

                    element.Properties = element.Properties || {};
                    element.Properties[nameProp] = element.Properties[nameProp] || nameConverter(name);
                }

                if(element.Type === "AWS::IAM::Role"){
                    if(isObject(element.Properties) && Array.isArray(element.Properties["Policies"])){
                        const policies = element.Properties["Policies"];

                        for(let i = 0; i < policies.length; i++){
                            policies[i].PolicyName = prefix + toKebabCase(key) + "-inline-iam-policy-" + i;
                        }
                    }
                }
            }
        });
    }

    return content;
}

/**
 * inserts auto generated serverless function names if none are already set,
 * these are generated by concatenating the prefix and the logic function name converted to by
 * the converter which defaults to a kebab case converter
 * @param {*} options.content
 * @param {String} options.prefix
 * @param {Function} [options.converter=toKebabCase]
 * @returns {*}
 */
function insertSlsFunctionNames(options) {
    const { content, prefix, converter = toKebabCase } = options;

    if(isObject(content)){
        Object.keys(content).forEach((key) => {
            const element = content[key];

            if(isObject(element)){
                insertSlsFunctionNames({ ...options, content: element });

                if(element["handler"]){
                    const name = prefix + converter(key);
                    element.name = element.name || name;
                }
            }
        });
    }

    return content;
}


/**
 * capitalize string
 * @param {String} str
 * @returns {String}
 */
function capitalizeString(str){
    return str.length > 0 ? str[0].toUpperCase() + str.substr(1) : "";
}

/**
 * concatenates strings
 * @param {String[]} arr
 * @returns {String}
 */
function concatStrings(arr){
    let str = "";
    arr.forEach((str2) => { str += str2; });
    return str;
}

/**
 * recursively goes through all strings values in content and
 * replaces occurrences of keys of vars with the values of vars
 * @param {Object} options.vars
 * @param {*} options.content
 * @returns {*}
 */
function replaceStrings(options) {
    const { vars, content } = options;

    let newContent = shallowCopy(content);

    if(isObject(newContent)){
        Object.keys(newContent).forEach((key) => {
            newContent[key] = replaceStrings({ vars, content: newContent[key] });
        });
    } else if(typeof newContent === "string"){
        Object.keys(vars).forEach((key) => {
            newContent = newContent.replace(key, vars[key]);
        });
    }

    return newContent;
}

/**
 * recursively goes through all strings values in content and
 * replaces them with the value if they match a key in vars
 * @param {Object} options.vars
 * @param {*} options.content
 * @returns {*} - replaced content
 */
function replaceValues(options) {
    const { vars, content } = options;

    let newContent = shallowCopy(content);

    if(isObject(newContent)){
        Object.keys(newContent).forEach((key) => {
            if(Object.keys(vars).includes(newContent[key])){
                newContent[key] = copy(vars[newContent[key]]);
            }

            newContent[key] = replaceValues({ vars, content: newContent[key] });
        });
    }

    return newContent;
}

/**
 * reads string contents of a file
 * @param path
 * @returns {string}
 */
function file(path){
    return fs.readFileSync(path).toString();
}

/**
 * extracts objects of an array and adds their props to the siblings of the function call
 * @param {Object[]} arr
 * @returns {Object}
 */
function unpack(arr){
    const result = this.serverlessContext.templateFunctionSiblings;

    arr.forEach((obj) => {
        Object.keys(obj).forEach((key) => {
            if(Object.keys(result).includes(key)){
                throw new Error("unpacking failure due to \"" + key + "\" being defined multiple times");
            }

            result[key] = obj[key];
        });
    });

    return result;
}

// noinspection JSUnusedGlobalSymbols
module.exports = {
    toKebabCase, isObject, shallowCopy, copy, setCallDel, mergeArrays, mergeProps,
    substitute, mapSubstitute, insertAwsResourceNames, capitalizeString, concatStrings,
    replaceStrings, replaceValues, file, unpack, insertSlsFunctionNames
};
