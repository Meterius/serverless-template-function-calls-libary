const { kebabCase } = require("change-case");
const fs = require("fs");
/**
 * replaces all occurrences of key in the string by the value
 * @param {string} str
 * @param {string} key
 * @param {string} value
 * @returns {string}
 */
function replaceAll(str, key, value) {
    for(let i = 0; i < str.length; i++){
        if(str.substr(i, key.length) === key){
            str = str.substr(0, i) + value + str.substr(i + key.length);
            i = i + value.length - 1;
        }
    }

    return str;
}

/**
 * replaces all occurrences of vars keys in the string by the values of vars
 * @param {string} str
 * @param {Object} vars
 * @returns {string}
 */
function replaceVars(str, vars) {
    let newStr = str;

    Object.keys(vars).forEach((varKey) => {
        newStr = replaceAll(newStr, varKey, vars[varKey]);
    });

    return newStr;
}

/**
 * converts string to kebab case
 * @param {String} str
 * @returns {String}
 */
function toKebabCase(str){
    return kebabCase(str);
}

/**
 * checks whether val is an object
 * @param {*} val
 * @returns {boolean}
 */
function isObject(val){
    return typeof val === "object" && val;
}

/**
 * create shallow copy
 * @param {*} val
 * @returns {*}
 */
function shallowCopy(val){
    if(Array.isArray(val)){
        return val.slice(0);
    } else if(isObject(val)){
        const copyObject = {};

        Object.keys(val).forEach((key) => {
            copyObject[key] = val[key];
        });

        return copyObject;
    } else {
        return val;
    }
}

/**
 * create deep copy
 * @param {*} val
 * @returns {*}
 */
function copy(val){
    if(Array.isArray(val)){
        return val.map(copy);
    } else if(isObject(val)){
        const copyObject = {};

        Object.keys(val).forEach((key) => {
            copyObject[key] = copy(val[key]);
        });

        return copyObject;
    } else {
        return val;
    }
}

/**
 * sets properties on element, calls the function on the element and resets properties on element to the previous values
 * @param {*} element
 * @param {Function} func
 * @param {Object} props
 */
function setCallDel(element, func, props){
    const prev = {};

    Object.keys(props).forEach((key) => {
        prev[key] = element[key];
        element[key] = props[key];
    });

    func(element);

    Object.keys(props).forEach((key) => {
        element[key] = prev[key];
    });
}

/**
 * merges elements of multiple arrays into single array
 * @param {Array[]} superArray
 * @returns {Array}
 */
function mergeArrays(superArray){
    const mergedArr = [];

    superArray.forEach((arr) => {
        mergedArr.concat(arr);
    });

    return mergedArr;
}

/**
 * merges properties ignoring ones with double underscores of objects in array into single object
 * @throws {Error} properties are not be specified multiple times
 * @param {Object[]} arr
 * @returns {Object}
 */
function mergeProps(arr) {
    const merged = {};
    const props = [];

    arr.forEach((container) => {
        Object.keys(container).forEach((prop) => {
            if(props.includes(prop)){
                throw new Error("merging properties encountered multiple definitions of \"" + prop + "\"");
            }

            if(prop.substr(0, 2) !== "__"){
                merged[prop] = container[prop];
                props.push(prop);
            }
        });
    });

    return merged;
}

/**
 * substitutes keys of vars in the keys and values of the content recursively with the values of vars
 * and values that match a key directly are replaced by that keys value
 * @param {Object} options
 * @param {Object} options.vars
 * @param {*} options.content
 * @returns {*}
 */
function substitute(options) {
    const { vars, content } = options;

    function recSub(element){
        if(isObject(element)) {
            if(Array.isArray(element)){
                return element.map(recSub);
            } else {
                const subElement = {};

                Object.keys(element).forEach((key) => {
                    subElement[replaceVars(key, vars)] = recSub(element[key]);
                });

                return subElement;
            }
        } else if(typeof element === "string"){
            if(Object.keys(vars).includes(element)){
                return recSub(vars[element]);
            } else {
                return replaceVars(element, vars);
            }
        } else {
            return element;
        }
    }

    return recSub(copy(content));
}

/**
 * returns each possible substitution by using each vars from the varsArray
 * @param {Object} options
 * @param {Object[]} options.varsArray
 * @param {*} options.content
 * @returns {Array}
 */
function mapSubstitute(options) {
    const { varsArray, content } = options;
    return varsArray.map((vars) => substitute({ vars, content }));
}

// /**
//  * inserts auto generated aws resource names if none are already set,
//  * these are generated by concatenating the prefix and the logic resource name converted to by
//  * the converter which defaults to a kebab case converter. also note that names are also generated
//  * for inline policy for aws roles and that for bucket names underscores are replaced by dots
//  * @param {*} options.content
//  * @param {String} options.prefix
//  * @param {Function} [options.converter=toKebabCase]
//  * @returns {*}
//  */
// function insertAwsResourceNames(options) {
//     const { content, prefix, converter = toKebabCase } = options;
//
//     const resTypeRegex = /^(?<type>AWS::.*::(?<localType>.*)(?!::))$/;
//
//     const normalNameTypes = ["AWS::CodeBuild::Project", "AWS::CodePipeline::Pipeline"];
//
//     const specialNameConverterTypes = {
//         "AWS::S3::Bucket": (name) => name.replace("_", ".")
//     };
//
//     if(isObject(content)){
//         Object.keys(content).forEach((key) => {
//             const element = content[key];
//
//             if(isObject(element)) {
//                 insertAwsResourceNames({ ...options, content: element });
//
//                 const typeData = resTypeRegex.exec(element.Type);
//                 if (typeData) {
//                     const nameConverter = specialNameConverterTypes[element.Type] || (name => name);
//                     const nameProp = normalNameTypes.includes(typeData.groups.type) ? "Name" : typeData.groups.localType + "Name";
//                     const name = prefix + converter(key);
//
//                     element.Properties = element.Properties || {};
//                     element.Properties[nameProp] = element.Properties[nameProp] || nameConverter(name);
//                 }
//
//                 if(element.Type === "AWS::IAM::Role"){
//                     if(isObject(element.Properties) && Array.isArray(element.Properties["Policies"])){
//                         const policies = element.Properties["Policies"];
//
//                         for(let i = 0; i < policies.length; i++){
//                             policies[i].PolicyName = prefix + toKebabCase(key) + "-inline-iam-policy-" + i;
//                         }
//                     }
//                 }
//             }
//         });
//     }
//
//     return content;
// }

// /**
//  * inserts auto generated serverless function names if none are already set,
//  * these are generated by concatenating the prefix and the logic function name converted to by
//  * the converter which defaults to a kebab case converter
//  * @param {*} options.content
//  * @param {String} options.prefix
//  * @param {Function} [options.converter=toKebabCase]
//  * @returns {*}
//  */
// function insertSlsFunctionNames(options) {
//     const { content, prefix, converter = toKebabCase } = options;
//
//     if(isObject(content)){
//         Object.keys(content).forEach((key) => {
//             const element = content[key];
//
//             if(isObject(element)){
//                 insertSlsFunctionNames({ ...options, content: element });
//
//                 if(element["handler"]){
//                     const name = prefix + converter(key);
//                     element.name = element.name || name;
//                 }
//             }
//         });
//     }
//
//     return content;
// }


/**
 * capitalize string
 * @param {String} str
 * @returns {String}
 */
function capitalizeString(str){
    return str.length > 0 ? str[0].toUpperCase() + str.substr(1) : "";
}

/**
 * concatenates strings
 * @param {String[]} arr
 * @returns {String}
 */
function concatStrings(arr){
    let str = "";
    arr.forEach((str2) => { str += str2; });
    return str;
}

/**
 * recursively goes through all strings values in content and
 * replaces occurrences of keys of vars with the values of vars
 * @param {Object} options.vars
 * @param {*} options.content
 * @returns {*}
 */
function replaceStrings(options) {
    const { vars, content } = options;

    let newContent = shallowCopy(content);

    if(isObject(newContent)){
        Object.keys(newContent).forEach((key) => {
            newContent[key] = replaceStrings({ vars, content: newContent[key] });
        });
    } else if(typeof newContent === "string"){
        return replaceVars(newContent, vars);
    }

    return newContent;
}

/**
 * recursively goes through all strings values in content and
 * replaces them with the value if they match a key in vars
 * @param {Object} options.vars
 * @param {*} options.content
 * @returns {*} - replaced content
 */
function replaceValues(options) {
    const { vars, content } = options;

    let newContent = shallowCopy(content);

    if(isObject(newContent)){
        Object.keys(newContent).forEach((key) => {
            if(Object.keys(vars).includes(newContent[key])){
                newContent[key] = copy(vars[newContent[key]]);
            }

            newContent[key] = replaceValues({ vars, content: newContent[key] });
        });
    }

    return newContent;
}

/**
 * reads string contents of a file
 * @param path
 * @returns {string}
 */
function file(path){
    return fs.readFileSync(path).toString();
}

/**
 * extracts objects of an array and adds their props to the siblings of the function call
 * @param {Object[]} arr
 * @returns {Object}
 */
function unpack(arr){
    const result = this.serverlessContext.templateFunctionSiblings;

    arr.forEach((obj) => {
        Object.keys(obj).forEach((key) => {
            if(Object.keys(result).includes(key)){
                throw new Error("unpacking failure due to \"" + key + "\" being defined multiple times");
            }

            result[key] = obj[key];
        });
    });

    return result;
}

// noinspection JSUnusedGlobalSymbols
module.exports = {
    toKebabCase, isObject, shallowCopy, copy, setCallDel, mergeArrays, mergeProps,
    substitute, mapSubstitute, capitalizeString, concatStrings,
    replaceStrings, replaceValues, file, unpack, replaceAll, replaceVars
};
